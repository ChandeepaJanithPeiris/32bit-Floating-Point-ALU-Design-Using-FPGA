module binary_division (
    input logic [3:0] Q, //dividend
    input logic [3:0] M, //divisor
    output logic signed [4:0] Qo,  //quotient
    output logic signed [4:0] A   //remainder
);

logic signed [4:0] M_extended;
logic signed [4:0] A_new;
logic [3:0] Q_local;

always_comb begin
    A = 5'b0;  // Initialize A to zero
    M_extended = {1'b0, M};  // Extend M to 5 bits
    Q_local = Q;  // Local copy of Q
    Qo = 5'b0;  // Initialize Qo

    for (int i = 4; i > 0; i--) begin
        // Shift left A and Q
        A = {A[3:0], Q_local[3]};  
        Q_local = Q_local << 1;

        // Subtract M_extended from A
        A_new = A - M_extended;

        // Check if subtraction result is negative
        if (A_new[4] == 1) begin
            Qo = {Qo[3:0], 1'b0};  // Append 0 to Qo
        end
        else begin
            Qo = {Qo[3:0], 1'b1};  // Append 1 to Qo
            A = A_new;  // Update A with the new value
        end
    end
end

endmodule
